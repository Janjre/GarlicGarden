<!DOCTYPE html>
<div id="container"></div>
<label for="stream-select">Data Streams:</label>
<select id="stream-select" multiple size="2">
  <option value="humidity">Humidity</option>
  <option value="temperature">Temperature</option>
</select>

<label for="window-select">Display Window:</label>
<select id="window-select">
  <option value="60">1 minute</option>
  <option value="600">10 minutes</option>
  <option value="3600">1 hour</option>
</select>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
import { io } from "https://cdn.socket.io/4.4.1/socket.io.esm.min.js";

const width = 640, height = 400, marginTop = 20, marginRight = 20, marginBottom = 30, marginLeft = 40;
const x = d3.scaleUtc().range([marginLeft, width - marginRight]);
const y = d3.scaleLinear().domain([0, 100]).range([height - marginBottom, marginTop]);
const svg = d3.create("svg").attr("width", width).attr("height", height);
const xAxisGroup = svg.append("g").attr("class", "x-axis").attr("transform", `translate(0,${height - marginBottom})`);
const yAxisGroup = svg.append("g").attr("class", "y-axis").attr("transform", `translate(${marginLeft},0)`);
container.append(svg.node());

const socket = io({ transports: ['websocket'], upgrade: false });
const streamColors = { humidity: "#1f77b4", temperature: "#ff8c00" };
let subscribedStreams = new Set();
let streamData = {};

let displayWindow = 60; // default to 1 minute
document.getElementById("window-select").addEventListener("change", (e) => {
    displayWindow = parseInt(e.target.value, 10);
    updateChart();
});

function subscribeToStreams(newStreams) {
    // Unsubscribe from streams that are no longer selected
    for (const stream of subscribedStreams) {
        if (!newStreams.has(stream)) {
            socket.emit("unsubscribe", { stream });
            socket.off(stream);
            delete streamData[stream];
        }
    }
    // Subscribe to new streams
    for (const stream of newStreams) {
        if (!subscribedStreams.has(stream)) {
            socket.emit("subscribe", { stream });
            // Handler for initial array or single new point
            socket.on(stream, data => {
                if (Array.isArray(data)) {
                    streamData[stream] = data;
                } else {
                    if (!streamData[stream]) streamData[stream] = [];
                    streamData[stream].push(data);
                }
                updateChart();
            });
            // Fetch initial data for the stream (optional, since subscribe sends it)
            fetch(`/data/${stream}`)
                .then(r => r.json())
                .then(data => {
                    streamData[stream] = data;
                    updateChart();
                });
        }
    }
    subscribedStreams = newStreams;
}

function updateChart() {
    // Flatten all data to get global x domain
    const now = Date.now() / 1000; // current time in seconds
    const allData = Object.values(streamData).flat();
    if (allData.length === 0) return;

    // Filter data to only include points within the selected window
    const filteredData = {};
    for (const [stream, data] of Object.entries(streamData)) {
        filteredData[stream] = data.filter(d => d.date >= now - displayWindow);
    }

    // Find min/max date for the filtered data
    const allFiltered = Object.values(filteredData).flat();
    if (allFiltered.length === 0) return;
    const minDate = d3.min(allFiltered, d => d.date);
    const maxDate = d3.max(allFiltered, d => d.date);
    const xBuffer = Math.max(1, (maxDate - minDate) * 0.05);

    x.domain([
        new Date((minDate - xBuffer) * 1000),
        new Date((maxDate + xBuffer) * 1000)
    ]);
    xAxisGroup.call(d3.axisBottom(x).tickFormat(d3.utcFormat("%H:%M:%S")));
    yAxisGroup.call(d3.axisLeft(y));

    // Data join for multiple lines
    const streams = Array.from(subscribedStreams);
    const lines = svg.selectAll(".data-line")
        .data(streams, d => d);

    // ENTER + UPDATE
    lines.enter()
        .append("path")
        .attr("class", "data-line")
        .attr("fill", "none")
        .attr("stroke-width", 2)
        .attr("stroke", d => streamColors[d] || "#000")
        .merge(lines)
        .attr("d", d => d3.line()
            .x(pt => x(new Date(pt.date * 1000)))
            .y(pt => y(pt.value))
            (filteredData[d] || [])
        );

    // EXIT
    lines.exit().remove();
}

// Handle multi-select changes
document.getElementById("stream-select").addEventListener("change", (e) => {
    const selected = new Set(Array.from(e.target.selectedOptions).map(opt => opt.value));
    subscribeToStreams(selected);
});

// Initial subscribe to both
subscribeToStreams(new Set(["humidity", "temperature"]));
</script>